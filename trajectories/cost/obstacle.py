from common import Model, Vector, Matrix
from cost import Cost

import numpy

class Obstacle(Cost):
    def __init__(self, model: Model, obstacle: Vector, radius: float):
        self.model = model
        self.obstacle = obstacle
        self.radius = radius
    
    def cost(self, q: Vector, step: float)->float:
        l = self.model.l
        r_obstacle = self.radius
        obstacle = self.obstacle

        return (-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**(-2.0)
    
    def d_cost(self, q: Vector, step: float)->Vector:
        l = self.model.l
        r_obstacle = self.radius
        obstacle = self.obstacle

        return numpy.array([[(-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[0])*l[0] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[0])*l[0])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, (-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[1])*l[1] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[1])*l[1])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, (-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[2])*l[2] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[2])*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, 0, 0, 0]])
    
    def dd_cost(self, q: Vector, step: float)->Matrix:
        l = self.model.l
        r_obstacle = self.radius
        obstacle = self.obstacle

        return numpy.array([[(-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[0])*l[0] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[0])*l[0])*(-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[0])*l[0] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[0])*l[0])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-(-4*numpy.sin(q[0])*l[0] - 4*numpy.sin(q[1])*l[1] - 4*numpy.sin(q[2])*l[2] + 4*obstacle[1])*numpy.sin(q[0])*l[0] + (4*numpy.cos(q[0])*l[0] + 4*numpy.cos(q[1])*l[1] + 4*numpy.cos(q[2])*l[2] - 4*obstacle[0])*numpy.cos(q[0])*l[0] - 4*numpy.sin(q[0])**2*l[0]**2 - 4*numpy.cos(q[0])**2*l[0]**2)/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, (-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[0])*l[0] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[0])*l[0])*(-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[1])*l[1] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[1])*l[1])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-4*numpy.sin(q[0])*numpy.sin(q[1])*l[0]*l[1] - 4*numpy.cos(q[0])*numpy.cos(q[1])*l[0]*l[1])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, (-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[0])*l[0] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[0])*l[0])*(-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[2])*l[2] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[2])*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-4*numpy.sin(q[0])*numpy.sin(q[2])*l[0]*l[2] - 4*numpy.cos(q[0])*numpy.cos(q[2])*l[0]*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, 0, 0, 0], [(-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[0])*l[0] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[0])*l[0])*(-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[1])*l[1] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[1])*l[1])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-4*numpy.sin(q[0])*numpy.sin(q[1])*l[0]*l[1] - 4*numpy.cos(q[0])*numpy.cos(q[1])*l[0]*l[1])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, (-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[1])*l[1] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[1])*l[1])*(-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[1])*l[1] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[1])*l[1])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-(-4*numpy.sin(q[0])*l[0] - 4*numpy.sin(q[1])*l[1] - 4*numpy.sin(q[2])*l[2] + 4*obstacle[1])*numpy.sin(q[1])*l[1] + (4*numpy.cos(q[0])*l[0] + 4*numpy.cos(q[1])*l[1] + 4*numpy.cos(q[2])*l[2] - 4*obstacle[0])*numpy.cos(q[1])*l[1] - 4*numpy.sin(q[1])**2*l[1]**2 - 4*numpy.cos(q[1])**2*l[1]**2)/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, (-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[1])*l[1] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[1])*l[1])*(-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[2])*l[2] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[2])*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-4*numpy.sin(q[1])*numpy.sin(q[2])*l[1]*l[2] - 4*numpy.cos(q[1])*numpy.cos(q[2])*l[1]*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, 0, 0, 0], [(-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[0])*l[0] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[0])*l[0])*(-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[2])*l[2] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[2])*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-4*numpy.sin(q[0])*numpy.sin(q[2])*l[0]*l[2] - 4*numpy.cos(q[0])*numpy.cos(q[2])*l[0]*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, (-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[1])*l[1] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[1])*l[1])*(-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[2])*l[2] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[2])*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-4*numpy.sin(q[1])*numpy.sin(q[2])*l[1]*l[2] - 4*numpy.cos(q[1])*numpy.cos(q[2])*l[1]*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, (-6*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[2])*l[2] + 6*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[2])*l[2])*(-4*(numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])*numpy.cos(q[2])*l[2] + 4*(numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])*numpy.sin(q[2])*l[2])/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**4 + (-(-4*numpy.sin(q[0])*l[0] - 4*numpy.sin(q[1])*l[1] - 4*numpy.sin(q[2])*l[2] + 4*obstacle[1])*numpy.sin(q[2])*l[2] + (4*numpy.cos(q[0])*l[0] + 4*numpy.cos(q[1])*l[1] + 4*numpy.cos(q[2])*l[2] - 4*obstacle[0])*numpy.cos(q[2])*l[2] - 4*numpy.sin(q[2])**2*l[2]**2 - 4*numpy.cos(q[2])**2*l[2]**2)/(-r_obstacle + (numpy.sin(q[0])*l[0] + numpy.sin(q[1])*l[1] + numpy.sin(q[2])*l[2] - obstacle[1])**2 + (numpy.cos(q[0])*l[0] + numpy.cos(q[1])*l[1] + numpy.cos(q[2])*l[2] - obstacle[0])**2)**3, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]])

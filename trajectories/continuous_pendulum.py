#!/usr/bin/python3

'''
    Непрерывный трёхсекционный маятник без потери энергии без управления

    \ddot q = - M^{-1}(q) L(q, \dot q) 
'''

from typing import Tuple

import numpy as np
from common import Vector, Matrix
from common import t_start, t_final, z_start, g, l, m, I

import matplotlib.pyplot as plt
import matplotlib.animation as animation

import scipy.integrate


# Предпосчитано:

def M_inv(z:Vector) -> Matrix:
    return Matrix([
    [
        (-l[0]*l[1]*(m[1]/2 - m[2])*(-l[0]*l[1]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) - (l[0]*l[1]*(m[1]/2 - m[2])*(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)*np.cos(z[0] - z[1])/((I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))*(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])) - l[0]*l[2]*m[2]*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))))*(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)/(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])))*np.cos(z[0] - z[1])/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]) - l[0]*l[2]*m[2]*(l[0]*l[1]*(m[1]/2 - m[2])*(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)*np.cos(z[0] - z[1])/((I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))*(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])) - l[0]*l[2]*m[2]*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))))*np.cos(z[0] - z[2])/(2*(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]))) + 1)/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))
        ,
        (-l[0]*l[1]*(m[1]/2 - m[2])*((-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/((I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])*(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]))) + 1)*np.cos(z[0] - z[1])/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]) + l[0]*l[2]*m[2]*(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)*np.cos(z[0] - z[2])/(2*(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])*(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]))))/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))
        ,
        (l[0]*l[1]*(m[1]/2 - m[2])*(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)*np.cos(z[0] - z[1])/((I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])*(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]))) - l[0]*l[2]*m[2]*np.cos(z[0] - z[2])/(2*(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]))))/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))
    ]
    ,
    [
        (-l[0]*l[1]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) - (l[0]*l[1]*(m[1]/2 - m[2])*(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)*np.cos(z[0] - z[1])/((I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))*(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])) - l[0]*l[2]*m[2]*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))))*(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)/(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])))/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])
        ,
        ((-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/((I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])*(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]))) + 1)/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])
        ,
        -(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)/((I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])*(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])))
    ]
    ,
    [
        (l[0]*l[1]*(m[1]/2 - m[2])*(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)*np.cos(z[0] - z[1])/((I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))*(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])) - l[0]*l[2]*m[2]*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))))/(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]))
        ,
        -(-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)/((I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])*(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2])))
        ,
        1/(I[2] - l[0]**2*l[2]**2*m[2]**2*np.cos(z[0] - z[2])**2/(4*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[2]**2*m[2]/4 - (-l[0]**2*l[1]*l[2]*m[2]*(m[1]/2 - m[2])*np.cos(z[0] - z[1])*np.cos(z[0] - z[2])/(2*(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2]))) + l[1]*l[2]*m[2]*np.cos(z[1] - z[2])/2)**2/(I[1] - l[0]**2*l[1]**2*(m[1]/2 - m[2])**2*np.cos(z[0] - z[1])**2/(I[0] + l[0]**2*(m[0]/4 + m[1] + m[2])) + l[1]**2*m[1]/4 + l[1]**2*m[2]))
    ]
])

def L(z: Vector)->Vector:
    return Vector([
              g*l[0]*m[0]*np.cos(z[0])/2
            + g*l[0]*m[1]*np.cos(z[0])
            + g*l[0]*m[2]*np.cos(z[0])
            + l[0]*l[1]*m[1]*np.sin(z[0] - z[1])*z[4]**2/2
            + l[0]*l[1]*m[2]*np.sin(z[0] - z[1])*z[4]**2
            + l[0]*l[2]*m[2]*np.sin(z[0] - z[2])*z[5]**2/2
        ,
              g*l[1]*m[1]*np.cos(z[1])/2
            + g*l[1]*m[2]*np.cos(z[1])
            - l[0]*l[1]*m[1]*np.sin(z[0] - z[1])*z[3]**2/2
            - l[0]*l[1]*m[2]*np.sin(z[0] - z[1])*z[3]**2
            + l[1]*l[2]*m[2]*np.sin(z[1] - z[2])*z[5]**2/2
        ,
              g*l[2]*m[2]*np.cos(z[2])/2
            - l[0]*l[2]*m[2]*np.sin(z[0] - z[2])*z[3]**2/2
            - l[1]*l[2]*m[2]*np.sin(z[1] - z[2])*z[4]**2/2
    ])

def z2theta(z: Vector) -> Tuple[Vector, Vector]:
    theta = z[:3]
    dtheta = z[3:]
    return (theta, dtheta)

def theta2z(theta: Vector, dtheta: Vector) -> Vector:
    return np.concatenate((theta, dtheta))


def func(t: float, z: Vector)->Vector:
    theta, dtheta = z2theta(z)
    ddtheta = np.matmul(M_inv(theta), Vector([0.0, 0.0, 0.0])) +  np.matmul(M_inv(theta), -L(z))
    return np.concatenate((dtheta, ddtheta))

res = scipy.integrate.solve_ivp(func, (t_start, t_final), z_start, max_step=0.01)
if not res.success:
    print('ODE solver failed')
    print(res.message)
    exit(1)

fig = plt.figure()
ax = fig.add_subplot(111, autoscale_on=False, xlim=(-3, 3), ylim=(-3, 3))
ax.grid()
line, = ax.plot([], [], 'o-', lw=2)


time_template = 'time = %.1fs'
time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)

def init():
    line.set_data([], [])
    time_text.set_text('')
    return line, time_text

def animate(i):
    x = [0] + [
        sum([l[k] * np.cos(res.y[k][i]) for k in range(j+1)]) 
        for j in range(3)
    ]
    y = [0] + [
        sum([l[k] * np.sin(res.y[k][i]) for k in range(j+1)]) 
        for j in range(3)
    ]
    x_center = [0] + [
        sum([l[k] * np.cos(res.y[k][i]) for k in range(j)] + np.cos(res.y[j][i])/2) 
        for j in range(3)
    ]
    y_center = [0] + [
        sum([l[k] * np.sin(res.y[k][i]) for k in range(j)] + np.sin(res.y[j][i])/2) 
        for j in range(3)
    ]
    Pi = sum([m[i]*g*y_center[i] for i in range(3)])

    line.set_data(x, y)
    time_text.set_text('t = %.2fs P=%.2f' % (res.t[i], Pi))
    #time_text.set_text(time_template % (res.t[i]))
    return line, time_text

ani = animation.FuncAnimation(fig, animate, np.arange(1, len(res.t)),
                              interval=10, blit=True, init_func=init)


plt.show()